# 자료형

# 1. 수 자료형
## 1-1. 정수형
a = 1000    # 양의 정수
print(a)

b = -7      # 음의 정수
print(b)

c = 0       # 0
print(c)

## 1-2. 실수형
a = 123.45  # 양의 실수
print(a)

b = -123.45 # 음의 실수
print(b)

c = 5.      # 소수부가 0일 때 0을 생략
print(c)

d = -.7     # 정수부가 0일 때 0을 생략
print(d)

### 1-2-1. 지수 표현 방식 (e 다음에 오는 수는 10의 지수부)
###        유효숫자e^지수 = 유효숫자 * 10^지수
e = 1e9     # 10억(1,000,000,000) → 1 * 10^9
print(e)

f = 75.25e1 # 752.5 → 75.25 * 10^1
print(f)

g = 3954e-3 # 3.954 → 3954 * 10^-3
print(g)

### 1-2-2. 컴퓨터는 실수를 정확히 표현하지 못함
###        실수형을 저장하기 위해 4바이트 or 8바이트의 고정된 메모리를 할당하기 때문
h = 0.3 + 0.6   # 0.8999999999999999
print(h)
if h == 0.9:
    print(True)
else:
    print(False)
### 1-2-3. 소수점 값을 비교하는 문제라면 round() 함수를 사용
###        round(실수형 데이터, 반올림할 위치 - 1)
###        반올림 할 위치가 없다면 소수점 첫째 자리에서 반올림
i = 0.3 + 0.6
print(round(i, 4))  # 0.9
if round(i, 4) == 0.9:
    print(True)
else:
    print(False)
    
## 1-3. 수 자료형의 연산
num1 = 7
num2 = 3

print(num1 / num2)  # 나누기
print(num1 % num2)  # 나머지
print(num1 // num2) # 몫
print(num1 ** num2) # 거듭제곱

# 2. 리스트 자료형
## 2-1. 리스트 만들기
a = [1, 2, 3, 4, 5, 6, 7, 8, 9] # 1부터 9까지의 정수를 저장하는 리스트
print(a)
print(a[4]) # 리스트의 5번째 원소를 출력

b = list()  # 빈 리스트 선언 방법 1
print(b)
b = []      # 빈 리스트 선언 방법 2
print(b)

## 2-2. 리스트의 인덱싱과 슬라이싱
### 2-2-1. 인덱싱 : 인덱스 값을 입력하여 리스트의 특정 원소에 접근하는 것
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1])    # 뒤에서 1번째 원소 출력
print(a[-3])    # 뒤에서 3번째 원소 출력
a[3] = 7        # 4번째 원소 값 변경
print(a)

### 2-2-2. 슬라이싱 : 리스트에서 연속적인 위치를 갖는 원소를 가져와야 할 때 사용
###        배열[시작 인덱스 : 끝 인덱스 - 1]
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[1 : 4]) # 2번째 원소부터 4번째 원소까지 출력

## 2-3. 리스트 컴프리헨션 : 리스트를 초기화하는 방법 중 하나
##      [] 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화
arr1 = [i for i in range(20) if i % 2 == 1] # 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
print(arr1)

arr2 = [i * i for i in range(1, 10)]        # 1부터 9까지의 수의 제곱 값을 포함하는 리스트
print(arr2)

### 2-3-1. 리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용
### N * M 크기의 2차원 리스트 초기화
n = 3
m = 4
arr3 = [[0] * m for _ in range(n)]
print(arr3)

### N * M 크기의 2차원 리스트 초기화(잘못된 방법)
n = 3
m = 4
arr4 = [[0] * m] * n
print(arr4)
arr4[1][1] = 5
print(arr4) # arr4[1][1]의 값을 5로 바꾸었지만, 3개의 리스트에서 인덱스 1에 해당하는 원소들의 값이 모두 5로 바뀜
            # 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문
            # 따라서, 특정한 크기를 가지는 2차원 리스트를 초기화할 때에는 리스트 컴프리헨션을 이용해야 함

## 2-4. 리스트 관련 기타 메서드
a = [1, 4, 3]
print("기본 리스트: ", a)

a.append(2)             # 리스트 마지막에 원소 삽입
print("삽입: ", a)

a.sort()                # 오름차순 정렬
print("오름차순 정렬:", a)

a.sort(reverse = True)  # 내림차순 정렬
print("내림차순 정렬:", a)

a.reverse()             # 리스트 원소 뒤집기
print("원소 뒤집기:", a)

a.insert(2, 3)          # 특정 인덱스에 데이터 추가
print("인덱스 2에 3 추가:", a)

# 특정 값을 가진 데이터의 개수
print("값이 3인 데이터 개수: ", a.count(3))

a.remove(1)             # 특정 값 데이터 삭제
print("값이 1인 데이터 삭제: ", a)

#### (참고 1) 언더바(_)의 역할은?
#### 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 사용
for _ in range(5):
    print("Hello")

#### (참고 2) insert() 메서드와 append() 메서드
#### 1) insert() 메서드를 사용할 때 원소의 개수가 N개면, 시간 복잡도는 O(N)
#### 2) append() 메서드는 O(1)에 수행되는 데에 반해 insert() 메서드는 동작이 느림
####  2-1) 중간에 원소를 삽입한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문
#### 3) insert() 메서드를 남발하면 '시간 초과'가 될 수 있음

#### (참고 3) remove() 메서드
#### 1) remove()의 시간 복잡도는 insert() 메서드와 마찬가지로 O(N)
####  1-1) 리스트에서 중간에 있는 원소를 삭제한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문
#### 2) 특정한 값의 원소를 모두 제거하려면?
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]  # a의 원소가 remove_set에 포함되어 있지 않을 때만 result 리스트 변수에 저장
print(result)

# 3. 문자열 자료형
## 3-1. 문자열 초기화
data = "Hello World"
print(data)

data = "Don't you know \"Python\"?"
print(data)

## 3-2. 문자열 연산
str1 = "Hello"
str2 = "World"
print(str1 + " " + str2)    # 문자열 더하기

str3 = "String"
print(str3 * 3)             # 문자열 반복

str4 = "ABCDEF"
print(str4[1])              # 문자열 인덱싱
print(str4[2 : 4])          # 문자열 슬라이싱

# 4. 튜플 자료형
#    : 리스트와 비슷하지만 한 번 선언된 값을 바꿀 수 없고, 소괄호()를 사용
a = (1, 2, 3, 4)    # 튜플 선언
print(a)
# a[2] = 7          # 튜플의 특정한 값을 변경하면 에러 발생

# 5. 사전 자료형
#    : 키와 값의 쌍을 데이터로 가지는 자료형
#    : 검색 및 수정에 있어서 O(1)의 시간에 처리 가능 → 리스트보다 빠르게 동작함
data = dict()
data["사과"] = "Apple"
data["바나나"] = "Banana"
data["코코넛"] = "Coconut"
print(data)

## 5-1. 사전 자료형에 특정 원소가 있는지 검사(리스트나 튜플에서도 사용 가능)
##      : 원소 in 사전
if "사과" in data:
    print("'사과'를 키로 가지는 데이터가 존재합니다.")

## 5-2. 사전 자료형 관련 함수
key_list = data.keys()      # 키 데이터만 담은 리스트 → keys() 함수
print(key_list)

value_list = data.values()  # 값 데이터만 담은 리스트 → values() 함수
print(value_list)

for key in key_list:        # 각 키에 따른 값을 하나씩 출력
    print(data[key])

# 6. 집합 자료형
#    : 중복을 허용하지 않음, 순서가 없음(인덱싱 불가)
#    : 시간 복잡도는 사전 자료형과 마찬가지로 O(1)

## 6-1. 집합 자료형 초기화
data = set([1, 1, 2, 3, 4, 4, 5])   # 집합 자료형 초기화 방법 1
print(data)

data = {1, 1, 2, 3, 4, 4, 5}        # 집합 자료형 초기화 방법 2
print(data)

## 6-2. 집합 자료형 연산
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

print("합집합: ", a | b)   # 합집합
print("교집합: ", a & b)   # 교집합
print("차집합: ", a - b)   # 차집합

## 6-3. 집합 자료형 관련 함수
##      : add(), remove() 함수는 시간 복잡도가 O(1)
data = set([1, 2, 3])
print("기본 집합: ", data)

data.add(4)                     # 새로운 원소 추가 : add()
print("원소 추가: ", data)

data.update([5, 6])             # 여러 개의 원소 추가 : update()
print("여러 원소 추가: ", data)

data.remove(3)                  # 특정 원소 제거 : remove()
print("3  삭제: ", data)