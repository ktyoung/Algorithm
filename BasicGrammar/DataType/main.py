# 자료형

# 1. 수 자료형
## 1-1. 정수형
a = 1000    # 양의 정수
print(a)

b = -7      # 음의 정수
print(b)

c = 0       # 0
print(c)

## 1-2. 실수형
a = 123.45  # 양의 실수
print(a)

b = -123.45 # 음의 실수
print(b)

c = 5.      # 소수부가 0일 때 0을 생략
print(c)

d = -.7     # 정수부가 0일 때 0을 생략
print(d)

### 1-2-1. 지수 표현 방식 (e 다음에 오는 수는 10의 지수부)
###        유효숫자e^지수 = 유효숫자 * 10^지수
e = 1e9     # 10억(1,000,000,000) → 1 * 10^9
print(e)

f = 75.25e1 # 752.5 → 75.25 * 10^1
print(f)

g = 3954e-3 # 3.954 → 3954 * 10^-3
print(g)

### 1-2-2. 컴퓨터는 실수를 정확히 표현하지 못함
###        실수형을 저장하기 위해 4바이트 or 8바이트의 고정된 메모리를 할당하기 때문
h = 0.3 + 0.6   # 0.8999999999999999
print(h)
if h == 0.9:
    print(True)
else:
    print(False)
### 1-2-3. 소수점 값을 비교하는 문제라면 round() 함수를 사용
###        round(실수형 데이터, 반올림할 위치 - 1)
###        반올림 할 위치가 없다면 소수점 첫째 자리에서 반올림
i = 0.3 + 0.6
print(round(i, 4))  # 0.9
if round(i, 4) == 0.9:
    print(True)
else:
    print(False)
    
## 1-3. 수 자료형의 연산
num1 = 7
num2 = 3

print(num1 / num2)  # 나누기
print(num1 % num2)  # 나머지
print(num1 // num2) # 몫
print(num1 ** num2) # 거듭제곱

# 2. 리스트 자료형
## 2-1. 리스트 만들기
a = [1, 2, 3, 4, 5, 6, 7, 8, 9] # 1부터 9까지의 정수를 저장하는 리스트
print(a)
print(a[4]) # 리스트의 5번째 원소를 출력

b = list()  # 빈 리스트 선언 방법 1
print(b)
b = []      # 빈 리스트 선언 방법 2
print(b)

## 2-2. 리스트의 인덱싱과 슬라이싱
### 2-2-1. 인덱싱 : 인덱스 값을 입력하여 리스트의 특정 원소에 접근하는 것
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1])    # 뒤에서 1번째 원소 출력
print(a[-3])    # 뒤에서 3번째 원소 출력
a[3] = 7        # 4번째 원소 값 변경
print(a)

### 2-2-2. 슬라이싱 : 리스트에서 연속적인 위치를 갖는 원소를 가져와야 할 때 사용
###        배열[시작 인덱스 : 끝 인덱스 - 1]
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[1 : 4]) # 2번째 원소부터 4번째 원소까지 출력

## 2-3. 리스트 컴프리헨션 : 리스트를 초기화하는 방법 중 하나
##      [] 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화
arr1 = [i for i in range(20) if i % 2 == 1] # 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
print(arr1)

arr2 = [i * i for i in range(1, 10)]        # 1부터 9까지의 수의 제곱 값을 포함하는 리스트
print(arr2)

### 2-3-1. 리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용
### N * M 크기의 2차원 리스트 초기화
n = 3
m = 4
arr3 = [[0] * m for _ in range(n)]
print(arr3)

### N * M 크기의 2차원 리스트 초기화(잘못된 방법)
n = 3
m = 4
arr4 = [[0] * m] * n
print(arr4)
arr4[1][1] = 5
print(arr4) # arr4[1][1]의 값을 5로 바꾸었지만, 3개의 리스트에서 인덱스 1에 해당하는 원소들의 값이 모두 5로 바뀜
            # 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문
            # 따라서, 특정한 크기를 가지는 2차원 리스트를 초기화할 때에는 리스트 컴프리헨션을 이용해야 함

## 2-4. 리스트 관련 기타 메서드
a = [1, 4, 3]
print("기본 리스트: ", a)

a.append(2)             # 리스트 마지막에 원소 삽입
print("삽입: ", a)

a.sort()                # 오름차순 정렬
print("오름차순 정렬:", a)

a.sort(reverse = True)  # 내림차순 정렬
print("내림차순 정렬:", a)

a.reverse()             # 리스트 원소 뒤집기
print("원소 뒤집기:", a)

a.insert(2, 3)          # 특정 인덱스에 데이터 추가
print("인덱스 2에 3 추가:", a)

# 특정 값을 가진 데이터의 개수
print("값이 3인 데이터 개수: ", a.count(3))

a.remove(1)             # 특정 값 데이터 삭제
print("값이 1인 데이터 삭제: ", a)

#### (참고 1) 언더바(_)의 역할은?
#### 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 사용
for _ in range(5):
    print("Hello")

#### (참고 2) insert() 메서드와 append() 메서드
#### 1) insert() 메서드를 사용할 때 원소의 개수가 N개면, 시간 복잡도는 O(N)
#### 2) append() 메서드는 O(1)에 수행되는 데에 반해 insert() 메서드는 동작이 느림
####  2-1) 중간에 원소를 삽입한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문
#### 3) insert() 메서드를 남발하면 '시간 초과'가 될 수 있음

#### (참고 3) remove() 메서드
#### 1) remove()의 시간 복잡도는 insert() 메서드와 마찬가지로 O(N)
####  1-1) 리스트에서 중간에 있는 원소를 삭제한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문
#### 2) 특정한 값의 원소를 모두 제거하려면?
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]  # a의 원소가 remove_set에 포함되어 있지 않을 때만 result 리스트 변수에 저장
print(result)